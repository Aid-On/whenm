%% =============================================================================
%% WhenM Event Calculus
%% =============================================================================
%%
%% Temporal reasoning engine for LLM memory systems.
%% "過去のある時点で何が真だったか" を推論する。
%%
%% Performance (optimized with cut in clipped/3):
%%   - Insert: >25,000 events/sec
%%   - Single fluent query: ~1ms
%%   - All fluents query:
%%     - 100 events: ~8-30ms
%%     - 500 events: ~110ms (no terminations), ~740ms (with terminations)
%%   - Point-in-time query: ~10-30ms
%%   - Acceptable for LLM use (typically <1000 events, mostly single queries)
%%
%% Two APIs generate events:
%%
%% 1. High-level API (memory.record):
%%    - "user learned Python" → started_knows("user", "Python")
%%    - "user became tech_lead" → became_role("user", "tech_lead")
%%    - "user quit chess_club" → stopped_member_of("user", "chess_club")
%%    Always uses: started_, became_, stopped_ patterns
%%
%% 2. Low-level API (ec.assertEvent):
%%    - got_job(user, "プログラマー")
%%    - moved_to(user, "東京")
%%    Uses semantic event names directly
%%
%% =============================================================================

:- dynamic(happens/2).
:- dynamic(initiates/2).
:- dynamic(terminates/2).
:- dynamic(current_date/1).

% Default date - will be overridden at runtime
current_date("2025-01-01").

%% =============================================================================
%% Core Event Calculus
%% =============================================================================

%% A fluent holds at time T if:
%% 1. Some event initiated it at or before T
%% 2. No event terminated it between initiation and T
holds_at(Fluent, T) :-
    happens(Event, T1),
    initiates(Event, Fluent),
    T1 @=< T,
    \+ clipped(T1, Fluent, T).

%% A fluent is clipped (terminated) between T1 and T2
%% Optimized: Early termination with cut (!) - stops on first termination found
clipped(T1, Fluent, T2) :-
    happens(Event, T),
    T1 @< T,
    T @=< T2,
    terminates(Event, Fluent),
    !.  % Cut: stop searching after first termination found

%% Query for "now" (uses current_date)
holds_now(Fluent) :-
    current_date(T),
    holds_at(Fluent, T).

%% =============================================================================
%% Pattern-Based Rules (for high-level API)
%% =============================================================================
%%
%% These patterns are generated by smart-assert.ts:
%%
%% | 入力                        | 生成イベント                | fluent          |
%% |-----------------------------|----------------------------|-----------------|
%% | "user learned Python"       | started_knows(...)         | knows(蓄積)     |
%% | "user joined chess_club"    | started_member_of(...)     | member_of(蓄積) |
%% | "user bought car"           | started_has(...)           | has(蓄積)       |
%% | "user became tech_lead"     | became_role(...)           | role(単一)      |
%% | "user moved_to Tokyo"       | became_lives_in(...)       | lives_in(単一)  |
%% | "user quit chess_club"      | stopped_member_of(...)     | member_of(終了) |
%% | "user sold car"             | stopped_has(...)           | has(終了)       |
%%
%% =============================================================================

%% Helper: Extract prefix and build fluent
pattern_fluent(Prefix, Event, Fluent) :-
    Event =.. [EventName | Args],
    atom_concat(Prefix, FluentName, EventName),
    FluentName \= '',
    Fluent =.. [FluentName | Args].

%% Helper: Wildcard matching for singular fluents
%% Only wildcard the VALUE (second arg), not the SUBJECT (first arg)
pattern_fluent_wildcard(Prefix, Event, Fluent) :-
    Event =.. [EventName | [Subject | RestArgs]],
    atom_concat(Prefix, FluentName, EventName),
    FluentName \= '',
    % Keep the subject, wildcard the rest
    length(RestArgs, RestLen),
    length(WildRestArgs, RestLen),
    append([Subject], WildRestArgs, FluentArgs),
    Fluent =.. [FluentName | FluentArgs].

%% --- ACCUMULATING: started_ → initiates ---
initiates(Event, Fluent) :- pattern_fluent(started_, Event, Fluent).

%% --- ACCUMULATING: stopped_, quit_, ended_, finished_ → terminates ---
terminates(Event, Fluent) :- pattern_fluent(stopped_, Event, Fluent).
terminates(Event, Fluent) :- pattern_fluent(quit_, Event, Fluent).
terminates(Event, Fluent) :- pattern_fluent(ended_, Event, Fluent).
terminates(Event, Fluent) :- pattern_fluent(finished_, Event, Fluent).

%% --- SINGULAR: became_, set_, got_, changed_ → initiates + terminates old ---
initiates(Event, Fluent) :- pattern_fluent(became_, Event, Fluent).
initiates(Event, Fluent) :- pattern_fluent(set_, Event, Fluent).
initiates(Event, Fluent) :- pattern_fluent(got_, Event, Fluent).
initiates(Event, Fluent) :- pattern_fluent(changed_, Event, Fluent).

terminates(Event, Fluent) :- pattern_fluent_wildcard(became_, Event, Fluent).
terminates(Event, Fluent) :- pattern_fluent_wildcard(set_, Event, Fluent).
terminates(Event, Fluent) :- pattern_fluent_wildcard(got_, Event, Fluent).
terminates(Event, Fluent) :- pattern_fluent_wildcard(changed_, Event, Fluent).

%% =============================================================================
%% Semantic Event Rules (for low-level API)
%% =============================================================================
%%
%% These handle direct event assertions like:
%%   ec.assertEvent('got_job(user, "プログラマー")', date)
%%
%% Used by: tools.ts memory_assert, direct WhenMEngine usage
%%
%% =============================================================================

%% --- Knowledge/Skills ---
%% learned(Person, Skill) → knows(Person, Skill)
initiates(learned(P, S), knows(P, S)).
initiates(studied(P, S), knows(P, S)).
initiates(mastered(P, S), knows(P, S)).

%% met(Person, Other) → knows(Person, Other)
initiates(met(P, O), knows(P, O)).

%% --- Membership ---
%% joined(Person, Group) → member_of(Person, Group)
initiates(joined(P, G), member_of(P, G)).

%% left/quit → terminates member_of
terminates(left(P, G), member_of(P, G)).
terminates(quit(P, G), member_of(P, G)).

%% --- Possession ---
%% bought/acquired/got → has (accumulating)
initiates(bought(P, T), has(P, T)).
initiates(acquired(P, T), has(P, T)).
initiates(obtained(P, T), has(P, T)).
initiates(got(P, T), has(P, T)).

%% sold/lost → terminates has
terminates(sold(P, T), has(P, T)).
terminates(lost(P, T), has(P, T)).

%% --- Jobs/Roles (singular) ---
%% got_job/quit_job handled by got_/quit_ patterns
%% became handled by became_ pattern

%% --- Location (singular) ---
%% moved_to → lives_in (singular: new location replaces old)
initiates(moved_to(P, L), lives_in(P, L)).
terminates(moved_to(P, _), lives_in(P, _)).

initiates(relocated_to(P, L), lives_in(P, L)).
terminates(relocated_to(P, _), lives_in(P, _)).

%% --- Relationships ---
%% married → married_to (singular)
initiates(married(P, S), married_to(P, S)).
terminates(married(P, _), married_to(P, _)).
terminates(divorced(P, S), married_to(P, S)).

%% --- Likes/Preferences ---
%% Note: started_liking/stopped_liking use pattern matching (started_/stopped_ → liking)
%% But we want the fluent to be "likes" not "liking", so we add explicit rules
initiates(started_liking(P, T), likes(P, T)).
terminates(stopped_liking(P, T), likes(P, T)).

%% --- Dislikes ---
initiates(started_disliking(P, T), dislikes(P, T)).
terminates(stopped_disliking(P, T), dislikes(P, T)).

%% --- Pets (3-arity) ---
initiates(got_pet(P, Type, Name), has_pet(P, Type, Name)).
terminates(lost_pet(P, Type, Name), has_pet(P, Type, Name)).

%% --- Business/Ownership ---
initiates(started_business(P, B), owns(P, B)).
initiates(founded(P, B), owns(P, B)).
terminates(closed_business(P, B), owns(P, B)).
terminates(sold_business(P, B), owns(P, B)).

%% --- Employment (singular) ---
initiates(hired_at(P, C), employed_at(P, C)).
initiates(joined_company(P, C), employed_at(P, C)).
terminates(hired_at(P, _), employed_at(P, _)).
terminates(joined_company(P, _), employed_at(P, _)).
terminates(left_company(P, C), employed_at(P, C)).
terminates(fired_from(P, C), employed_at(P, C)).

%% --- Projects ---
initiates(started_project(P, Proj), working_on(P, Proj)).
terminates(finished_project(P, Proj), working_on(P, Proj)).
terminates(abandoned_project(P, Proj), working_on(P, Proj)).

%% --- Learning (ongoing) ---
initiates(started_learning(P, S), learning(P, S)).
terminates(finished_learning(P, S), learning(P, S)).
terminates(stopped_learning(P, S), learning(P, S)).
%% When learning finishes, add to knows
initiates(finished_learning(P, S), knows(P, S)).

%% =============================================================================
%% Query Helpers
%% =============================================================================

%% Get all fluents that hold at time T
all_holding(T, Fluents) :-
    findall(F, holds_at(F, T), Fluents).

%% Get all events
all_events(Events) :-
    findall(happens(E, T), happens(E, T), Events).

%% Get events in time range
events_between(T1, T2, Events) :-
    findall(happens(E, T), (happens(E, T), T @>= T1, T @=< T2), Events).

%% Check if a fluent ever held
ever_held(Fluent) :-
    happens(Event, _),
    initiates(Event, Fluent).

%% Get timeline of a specific fluent
fluent_timeline(Fluent, Timeline) :-
    findall(
        event(Type, T),
        (
            (happens(E, T), initiates(E, Fluent), Type = started)
            ;
            (happens(E, T), terminates(E, Fluent), Type = ended)
        ),
        Timeline
    ).

%% =============================================================================
%% Utility Predicates
%% =============================================================================

%% Assert/retract helpers
assert_event(Event, Time) :- assertz(happens(Event, Time)).
retract_event(Event, Time) :- retract(happens(Event, Time)).

%% Clear events for a person
clear_person(Person) :-
    forall(
        (happens(Event, _), Event =.. [_ | [Person | _]]),
        retractall(happens(Event, _))
    ).

%% Clear all events
clear_all :- retractall(happens(_, _)).

%% Date comparison helpers (ISO format strings compare correctly with @<)
date_before(D1, D2) :- D1 @< D2.
date_after(D1, D2) :- D1 @> D2.
date_between(D, D1, D2) :- D @>= D1, D @=< D2.
